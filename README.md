# Currency Converter (Flutter)

Currency Converter app built with **Clean Architecture** (data/domain/presentation), **BLoC**, **get_it + injectable**, **Drift (SQLite)** caching, and an **offline-first** UX.

## Build instructions

### Prerequisites

- Flutter SDK installed (stable channel recommended)
- A simulator/emulator or physical device

### 1) Configure environment

This workspace uses `env` (asset) instead of `.env`.

- Copy `env.example` → `env`
- Set `API_KEY` (APILayer Exchangerates API key)

### 2) Install dependencies + generate code

```bash
flutter pub get
dart run build_runner build --delete-conflicting-outputs
```

### 3) Run

```bash
flutter run
```

### 4) Test

```bash
flutter test
```

## APIs

- **Rates API**: APILayer **Exchangerates API** (exchangeratesapi.io)  
  Docs: `https://docs.apilayer.com/exchangeratesapi/docs/api-documentation`
- **Flags**: `flagcdn.com` (country flags by ISO code)

## Architecture (Clean + SOLID)

Feature-first layout with strict boundaries:

- **presentation**: Widgets + BLoC only (no business logic)
- **domain**: Entities + repositories contracts + usecases
- **data**: DTOs, datasources, repository implementations

Cross-cutting code lives in `lib/core/` (Result/Failure, error mapping, DB, network helpers).

### Design pattern justification

The app uses **Clean Architecture** + **BLoC** because:

- **Testability**: domain usecases and blocs are easy to unit-test without Flutter bindings.
- **Maintainability**: strict boundaries keep UI, business rules, and data access independent.
- **Replaceable integrations**: API/database changes are isolated to the data layer.
- **Scalability**: feature-first structure keeps growth organized as screens/features increase.

## Design patterns used in this project

- **Singleton (via DI)**:
  - **Where**: `@lazySingleton` / `@LazySingleton` registrations generated by Injectable (see `lib/app/di/injection.dart`)
  - **Examples**: shared `Dio` client, Drift `AppDatabase` + DAOs, repositories/services
  - **Why**: reuse heavy objects, single DB connection, consistent caching/state (offline-first)

- **Dependency Injection + Service Locator (GetIt + Injectable)**:
  - **Where**: `lib/app/di/injection.dart` (`configureDependencies()` → generated `injection.config.dart`)
  - **Why**: constructor injection, easy swapping in tests, avoids manual wiring in UI

- **BLoC (state machine for UI)**:
  - **Where**: `lib/features/**/presentation/bloc/*_bloc.dart`
  - **Why**: predictable state transitions, separates UI from business logic, highly testable

- **Repository pattern**:
  - **Where**: contracts in `lib/features/**/domain/repositories/`, implementations in `lib/features/**/data/repositories/`
  - **Why**: domain layer depends on abstractions; data sources can change without affecting UI/domain

- **Use Case / Interactor pattern**:
  - **Where**: `lib/features/**/domain/usecases/` (e.g. `ConvertCurrency`, `RefreshCurrenciesIfStale`, `GetLast7Days`)
  - **Why**: one class per business action; improves discoverability and unit testing

- **Data Source pattern (Remote + Local)**:
  - **Where**: `lib/features/**/data/datasources/` (e.g. `RatesRemoteDataSource`, `RatesLocalDataSource`)
  - **Why**: isolates IO concerns (HTTP/DB) from repositories and domain logic

- **DTO / Model mapping**:
  - **Where**: `lib/features/**/data/models/` (API response parsing) and mappers in repositories/datasources
  - **Why**: keeps external JSON/schema changes out of the domain layer

- **Observer / Reactive streams**:
  - **Where**: Drift `watch*()` in DAOs and UI `StreamBuilder` (e.g. currency list)
  - **Why**: live UI updates when DB changes (favorites, currency list) without manual refresh plumbing

- **Result / Failure (functional error handling)**:
  - **Where**: `lib/core/result/result.dart` (`Success` / `FailureResult`)
  - **Why**: consistent error propagation across layers, simpler testing vs thrown exceptions

- **Strategy (staleness policy)**:
  - **Where**: `lib/core/utils/stale_policy.dart`
  - **Why**: central place to adjust cache freshness rules without touching repositories/UI

- **Interceptor (network cross-cutting)**:
  - **Where**: Dio `InterceptorsWrapper` in `lib/app/di/register_module.dart` (adds `access_key`)
  - **Why**: keeps auth/query concerns out of business logic and API calls

## Offline-first behavior

- App always renders from **local Drift cache** first.
- When offline, an **Offline mode banner** is shown and the app keeps working from cache.
- If cached data is stale (**> 12 hours**), the app performs a **background refresh** when online.

## Historical data

The app fetches last 7 days by requesting the **date endpoint** (`/{YYYY-MM-DD}`) for each day (cached in Drift).  
Example: `https://api.exchangeratesapi.io/v1/2023-11-15?access_key=...`

## Database (Drift / SQLite) justification

Drift gives:
- **Typed, compile-time safe queries**
- **Reactive streams** (`watch*`) used by BLoCs for live UI updates
- Great fit for offline-first caching (currencies, favorites, latest + historical rates)

## Flags / Image loader justification

Flags are loaded from `flagcdn.com` using `cached_network_image`:
- Caches images on device automatically
- Provides placeholders + error fallbacks for flaky networks
- Reduces bandwidth and improves scroll performance vs. repeatedly fetching images

## Testing

Included:
- **Unit tests** for usecases
- **bloc_test** for BLoC transitions
- **Widget tests** for key screens
- **Integration test** (`integration_test/app_flow_test.dart`) for basic navigation flow

## CI

GitHub Actions workflow (`.github/workflows/ci.yml`) runs:
- `dart format --set-exit-if-changed .`
- `flutter analyze`
- `flutter test`

