# Currency Converter (Flutter)

Currency Converter app built with **Clean Architecture** (data/domain/presentation), **BLoC**, **get_it + injectable**, **Drift (SQLite)** caching, and an **offline-first** UX.

## Build instructions

### Prerequisites

- Flutter SDK installed (stable channel recommended)
- A simulator/emulator or physical device

### 1) Configure environment

This workspace uses `env` (asset) instead of `.env`.

- Copy `env.example` → `env`
- Set `API_KEY` (APILayer Exchangerates API key)

### 2) Install dependencies + generate code

```bash
flutter pub get
dart run build_runner build --delete-conflicting-outputs
```

### 3) Run

```bash
flutter run
```

### 4) Test

```bash
flutter test
```

## APIs

- **Rates API**: APILayer **Exchangerates API** (exchangeratesapi.io)  
  Docs: `https://docs.apilayer.com/exchangeratesapi/docs/api-documentation`
- **Flags**: `flagcdn.com` (country flags by ISO code)

## Architecture (Clean + SOLID)

Feature-first layout with strict boundaries:

- **presentation**: Widgets + BLoC only (no business logic)
- **domain**: Entities + repositories contracts + usecases
- **data**: DTOs, datasources, repository implementations

Cross-cutting code lives in `lib/core/` (Result/Failure, error mapping, DB, network helpers).

### Design pattern justification

The app uses **Clean Architecture** + **BLoC** because:

- **Testability**: domain usecases and blocs are easy to unit-test without Flutter bindings.
- **Maintainability**: strict boundaries keep UI, business rules, and data access independent.
- **Replaceable integrations**: API/database changes are isolated to the data layer.
- **Scalability**: feature-first structure keeps growth organized as screens/features increase.

## Design patterns used in this project

- **Singleton (via DI)**:
  - **Where**: `@lazySingleton` / `@LazySingleton` registrations generated by Injectable (see `lib/app/di/injection.dart`)
  - **Examples**: shared `Dio` client, Drift `AppDatabase` + DAOs, repositories/services
  - **Why**: reuse heavy objects, single DB connection, consistent caching/state (offline-first)

- **Dependency Injection + Service Locator (GetIt + Injectable)**:
  - **Where**: `lib/app/di/injection.dart` (`configureDependencies()` → generated `injection.config.dart`)
  - **Why**: constructor injection, easy swapping in tests, avoids manual wiring in UI

- **BLoC (state machine for UI)**:
  - **Where**: `lib/features/**/presentation/bloc/*_bloc.dart`
  - **Why**: predictable state transitions, separates UI from business logic, highly testable

- **Repository pattern**:
  - **Where**: contracts in `lib/features/**/domain/repositories/`, implementations in `lib/features/**/data/repositories/`
  - **Why**: domain layer depends on abstractions; data sources can change without affecting UI/domain

- **Use Case / Interactor pattern**:
  - **Where**: `lib/features/**/domain/usecases/` (e.g. `ConvertCurrency`, `RefreshCurrenciesIfStale`, `GetLast7Days`)
  - **Why**: one class per business action; improves discoverability and unit testing

- **Data Source pattern (Remote + Local)**:
  - **Where**: `lib/features/**/data/datasources/` (e.g. `RatesRemoteDataSource`, `RatesLocalDataSource`)
  - **Why**: isolates IO concerns (HTTP/DB) from repositories and domain logic

- **DTO / Model mapping**:
  - **Where**: `lib/features/**/data/models/` (API response parsing) and mappers in repositories/datasources
  - **Why**: keeps external JSON/schema changes out of the domain layer

- **Observer / Reactive streams**:
  - **Where**: Drift `watch*()` in DAOs and UI `StreamBuilder` (e.g. currency list)
  - **Why**: live UI updates when DB changes (favorites, currency list) without manual refresh plumbing

- **Result / Failure (functional error handling)**:
  - **Where**: `lib/core/result/result.dart` (`Success` / `FailureResult`)
  - **Why**: consistent error propagation across layers, simpler testing vs thrown exceptions

- **Strategy (staleness policy)**:
  - **Where**: `lib/core/utils/stale_policy.dart`
  - **Why**: central place to adjust cache freshness rules without touching repositories/UI

- **Interceptor (network cross-cutting)**:
  - **Where**: Dio `InterceptorsWrapper` in `lib/app/di/register_module.dart` (adds `access_key`)
  - **Why**: keeps auth/query concerns out of business logic and API calls

## Offline-first behavior

- App always renders from **local Drift cache** first.
- When offline, an **Offline mode banner** is shown and the app keeps working from cache.
- If cached data is stale (**> 12 hours**), the app performs a **background refresh** when online.

## Local persistence (banking-style hygiene)

- **Stored data (non-sensitive only)**:
  - Currency catalog (code + name)
  - Favorites (currency codes)
  - Latest + historical exchange rates (cache)
- **No PII**:
  - No user accounts, no names/emails/phone numbers, no identifiers, no payment data.

### Data integrity (constraints)

Drift tables enforce uniqueness using primary keys (these are already implemented in the project):

- **Currencies**: `code` is the primary key (unique currency code)
- **Favorites**: `currencyCode` is the primary key
- **LatestRates**: `(fromCode, toCode)` is the composite primary key
- **HistoricalRates**: `(fromCode, toCode, date)` is the composite primary key (pair+day unique)

Additional integrity/performance hardening:

- **Foreign keys**: enabled at DB open time via `PRAGMA foreign_keys = ON;` (see `lib/core/persistence/app_database.dart`)
- **Index for retention cleanup**: `idx_historical_rates_date` on `historical_rates(date)` (see migrations below)

### Migrations strategy

Database migrations are handled by Drift using:

- `schemaVersion` + `MigrationStrategy` in `lib/core/persistence/app_database.dart`
- **Current schema version**: `2`
- **v2 upgrade**: adds `idx_historical_rates_date` (no data loss)

### Cache invalidation (retention)

To keep local storage bounded, the app **purges historical rates older than 30 days** during refresh.

### Optional encryption (if required)

If you require at-rest encryption (e.g., compliance), you can switch the SQLite backend to **SQLCipher**
while keeping the same table schema and repository/data-source design. Typical approaches:

- Use a SQLCipher-enabled SQLite implementation for Flutter (SQLCipher build), or a Drift-compatible SQLCipher package.
- Store the encryption key securely (platform keystore/keychain).

## Historical data

The app fetches last 7 days by requesting the **date endpoint** (`/{YYYY-MM-DD}`) for each day (cached in Drift).  
Example: `https://api.exchangeratesapi.io/v1/2023-11-15?access_key=...`

## Database (Drift / SQLite) justification

Drift gives:
- **Typed, compile-time safe queries**
- **Reactive streams** (`watch*`) used by BLoCs for live UI updates
- Great fit for offline-first caching (currencies, favorites, latest + historical rates)

## Flags / Image loader justification

Flags are loaded from `flagcdn.com` using `cached_network_image`:
- Caches images on device automatically
- Provides placeholders + error fallbacks for flaky networks
- Reduces bandwidth and improves scroll performance vs. repeatedly fetching images

## Testing

Included:
- **Unit tests** for usecases
- **bloc_test** for BLoC transitions
- **Widget tests** for key screens
- **Integration test** (`integration_test/app_flow_test.dart`) for basic navigation flow

## CI

GitHub Actions workflow (`.github/workflows/ci.yml`) runs:
- `dart format --set-exit-if-changed .`
- `flutter analyze`
- `flutter test`

